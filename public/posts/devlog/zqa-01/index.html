<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>ZQA Devlog 01 | Rahul&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
This is the first in a series of posts logging the development of zqa, a RAG tool I am working on to work with Zotero. The eventual goal is that you will be able to, from your terminal (as an avid terminal user myself), ask questions and have LLMs respond with citations from your Zotero library. I also want this tool to help you find things: so maybe you remember certain details about a paper but don&rsquo;t quite know what it was about or its title&ndash;a problem that has become all too real with my 1,300-item library. Why is it called zqa? Because I&rsquo;m not creative, and &ldquo;Zotero Q &amp; A&rdquo; was the first thing that popped into my head. Also, the letters in zqa happen to be very close, so it&rsquo;s easy enough to type.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/devlog/zqa-01/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/devlog/zqa-01/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
    
       <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>

    

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Rahul&#39;s Blog (Alt + H)">Rahul&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      ZQA Devlog 01
    </h1>
    <div class="post-meta"><span title='2025-04-16 20:23:29 -0400 EDT'>April 16, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>This is the first in a series of posts logging the development of <code>zqa</code>, a RAG tool I am working on to work with Zotero. The eventual goal is that you will be able to, from your terminal (as an avid terminal user myself), ask questions and have LLMs respond with citations from your Zotero library. I also want this tool to help you find things: so maybe you remember certain details about a paper but don&rsquo;t quite know what it was about or its title&ndash;a problem that has become all too real with my 1,300-item library. Why is it called <code>zqa</code>? Because I&rsquo;m not creative, and &ldquo;Zotero Q &amp; A&rdquo; was the first thing that popped into my head. Also, the letters in <code>zqa</code> happen to be very close, so it&rsquo;s easy enough to type.</p>
<p>I will be writing it in Rust, for a few reasons. First, it will avoid me having to Rewrite It In Rust later. Jokes aside, the benefits are twofold: I get to learn Rust by writing a real project in it, and second, because Rust has fewer high-level libraries that do everything for you, I will be forced to learn the details of how things work, which I think is very important for devs. Initially, I did start writing it in Python, but I grew increasingly frustrated with the lack of type enforcement by default and how I was not forced to think about low-level ideas like memory management.</p>
<p>I will be showing plenty of code, but it is not the full code. You can see that on <a href="https://github.com/yrahul3910/zotero-rag/">the GitHub repo</a>.</p>
<h1 id="getting-the-library">Getting the library<a hidden class="anchor" aria-hidden="true" href="#getting-the-library">#</a></h1>
<p>Zotero stores information about the library in a SQLite file. We can read this, but we first need to find it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_lib_path</span>() -&gt; Option<span style="color:#f92672">&lt;</span>PathBuf<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> env::consts::<span style="color:#66d9ef">OS</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;linux&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;macos&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;windows&#34;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            UserDirs::new().map(<span style="color:#f92672">|</span>user_dirs<span style="color:#f92672">|</span> PathBuf::from(user_dirs.home_dir()).join(<span style="color:#e6db74">&#34;Zotero&#34;</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> None,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Straightforward enough. Inside the directory returned by this function is a <code>zotero.sqlite</code> that we need to read. Now, we need to parse the info we need out of this table. After some spelunking through the table schemas, I decided I want titles, abstracts, locations of PDF attachments, and notes. A clever SQL <code>CASE WHEN</code> clause allows us to do this in one query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#e6db74">/// Parses the Zotero library. If successful, returns a list of metadata for each item.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_library</span>() -&gt; Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>ZoteroItemMetadata<span style="color:#f92672">&gt;</span>, LibraryParsingError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(path) <span style="color:#f92672">=</span> get_lib_path() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> conn <span style="color:#f92672">=</span> Connection::open(path.join(<span style="color:#e6db74">&#34;zotero.sqlite&#34;</span>))<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The SQL query essentially combines the titles and abstracts for each paper into a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// single row. This is done using GROUP BY on the keys, and MAX to get the field itself.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> stmt <span style="color:#f92672">=</span> conn.prepare(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;SELECT items.key AS libraryKey,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                MAX(CASE WHEN fieldsCombined.fieldName = &#39;title&#39; THEN itemDataValues.value END) AS title,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                MAX(CASE WHEN fieldsCombined.fieldName = &#39;abstract&#39; THEN itemDataValues.value END) AS abstract,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                itemNotes.note AS notes,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                itemAttachments.path AS filePath
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            FROM items
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            INNER JOIN itemData ON items.itemID = itemData.itemID
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            INNER JOIN fieldsCombined ON itemData.fieldID = fieldsCombined.fieldID
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            INNER JOIN itemDataValues ON itemData.valueID = itemDataValues.valueID
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            INNER JOIN itemAttachments ON items.itemID = itemAttachments.itemID
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            LEFT JOIN itemNotes ON items.itemID = itemNotes.itemID
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            WHERE fieldsCombined.fieldName IN (&#39;title&#39;, &#39;abstract&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            GROUP BY items.key;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> item_iter: Vec<span style="color:#f92672">&lt;</span>ZoteroItemMetadata<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> stmt
</span></span><span style="display:flex;"><span>            .query_map([], <span style="color:#f92672">|</span>row<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> res_path: String <span style="color:#f92672">=</span> row.get(<span style="color:#ae81ff">4</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> split_idx <span style="color:#f92672">=</span> res_path.find(<span style="color:#e6db74">&#39;:&#39;</span>).unwrap_or(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> res_path.split_at(split_idx).<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> lib_key: String <span style="color:#f92672">=</span> row.get(<span style="color:#ae81ff">0</span>)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Ok(ZoteroItemMetadata {
</span></span><span style="display:flex;"><span>                    library_key: <span style="color:#a6e22e">lib_key</span>.clone(),
</span></span><span style="display:flex;"><span>                    title: <span style="color:#a6e22e">row</span>.get(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>                    paper_abstract: <span style="color:#a6e22e">row</span>.get(<span style="color:#ae81ff">2</span>).unwrap_or_default(),
</span></span><span style="display:flex;"><span>                    notes: <span style="color:#a6e22e">row</span>.get(<span style="color:#ae81ff">3</span>)<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>                    file_path: <span style="color:#a6e22e">path</span>.join(<span style="color:#e6db74">&#34;storage&#34;</span>).join(lib_key).join(filename),
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>            })<span style="color:#f92672">?</span>
</span></span><span style="display:flex;"><span>            .filter_map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x.ok())
</span></span><span style="display:flex;"><span>            .collect();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Ok(item_iter)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        Err(LibraryParsingError::LibNotFoundError)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Good, we now have a way to get metadata from the library, including, most importantly for RAG, the locations to the PDF files. We would now like to proceed by storing embeddings of these in a vector database, but there&rsquo;s a more fundamental issue: how do you parse a PDF file? In Rust, libraries for PDFs don&rsquo;t automagically do this for you&ndash;and that is a <em>strength</em>, in my opinion. We get to learn how PDFs work!</p>
<h1 id="pdf-parsing">PDF Parsing<a hidden class="anchor" aria-hidden="true" href="#pdf-parsing">#</a></h1>
<p>We&rsquo;re at the most exciting part! First, let&rsquo;s understand how the PDF format works. A PDF file has its content as a sequence of bytes, and it has embedded information about things like fonts. As we will see, fonts in PDFs are triply-nested dictionaries&ndash;but that&rsquo;s for a later time. First, let&rsquo;s read the file itself.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extract_text</span>(file_path: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>String, Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> doc <span style="color:#f92672">=</span> Document::load(file_path)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> parser <span style="color:#f92672">=</span> PdfParser::with_default_config();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> doc
</span></span><span style="display:flex;"><span>        .page_iter()
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>page_id<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>            parser
</span></span><span style="display:flex;"><span>                .parse_content(<span style="color:#f92672">&amp;</span>doc, page_id)
</span></span><span style="display:flex;"><span>                .unwrap_or(<span style="color:#e6db74">&#34;&#34;</span>.to_string())
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>        .join(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Ok(content)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We are using the <code>lopdf</code> crate to help here. This crate gives us a more structured view into the PDF. It gives us a way to access the content as a byte stream as well as reading embedded metadata such as fonts through a function. We now need to write the <code>PdfParser</code> struct and implement its <code>parse_content</code> function.</p>
<p>First, let&rsquo;s understand how PDFs even work. The content of a PDF is a sequence of bytes containing what are essentially commands to the renderer. You can think of these commands as telling the renderer what to do. In general, at least for simple PDFs that don&rsquo;t <a href="https://github.com/ading2210/doompdf">implement Doom</a>, a renderer should be able to use a single pass to display the contents. The set of commands and their argument structure is nicely laid out in a <a href="https://opensource.adobe.com/dc-acrobat-sdk-docs/pdfstandards/pdfreference1.0.pdf">230 page document by Adobe</a>. We will not be reading that, obviously. Instead, we will take inspiration from <a href="https://adventures.michaelfbryan.com/posts/parsing-pdfs-in-rust/">this blog post</a>, which gives us the basics. I highly recommend this.</p>
<p>It turns out academic PDFs look mostly like this. We will also use the fact that at least for CS, most academics use LaTeX to typeset their documents. Which means that we can create simple PDF files and look at the resulting content bytes. Upon doing this, we notice that content is put inside <code>TJ</code> commands, which basically contain arrays of content instead of individual pieces of content like <code>Tj</code> does. We now know the first step:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> doc
</span></span><span style="display:flex;"><span>    .get_page_content(page_id)
</span></span><span style="display:flex;"><span>    .map_err(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> PdfError::ContentError)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> String::from_utf8_lossy(<span style="color:#f92672">&amp;</span>content).to_string();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> rem_content <span style="color:#f92672">=</span> content;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> parsed <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>rem_content.contains(<span style="color:#e6db74">&#34;TJ&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Inside the <code>TJ</code> command, we have words or subwords in parentheses, separated by numbers which tell the renderer how much to move the cursor (if you&rsquo;re old enough to remember <a href="https://en.wikipedia.org/wiki/Logo_(programming_language)">Logo</a>, similar idea). Let&rsquo;s parse these.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#75715e">/* Here&#39;s our strategy. We&#39;ll look for pairs of (), consuming words inside.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Then, we&#39;ll consume an integer. If that integer is less than SAME_WORD_THRESHOLD, the next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * chunk will be appended to the current word. Otherwise, we add a space. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> cur_content.contains(<span style="color:#e6db74">&#39;(&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> idx1 <span style="color:#f92672">=</span> cur_content.find(<span style="color:#e6db74">&#39;(&#39;</span>).ok_or(PdfError::ContentError)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> idx2 <span style="color:#f92672">=</span> cur_content.find(<span style="color:#e6db74">&#39;)&#39;</span>).ok_or(PdfError::ContentError)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> idx1 <span style="color:#f92672">&gt;=</span> idx2 {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>cur_content[idx2<span style="color:#f92672">..</span>].contains(<span style="color:#e6db74">&#39;(&#39;</span>) {
</span></span><span style="display:flex;"><span>        parsed <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> idx3 <span style="color:#f92672">=</span> cur_content[idx2<span style="color:#f92672">..</span>].find(<span style="color:#e6db74">&#39;(&#39;</span>).unwrap() <span style="color:#f92672">+</span> idx2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> spacing <span style="color:#f92672">=</span> cur_content[idx2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>idx3].parse::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>().unwrap().abs();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>(<span style="color:#ae81ff">0</span><span style="color:#f92672">..=</span>self.config.same_word_threshold).contains(<span style="color:#f92672">&amp;</span>spacing) {
</span></span><span style="display:flex;"><span>        parsed <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cur_content <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>cur_content[idx2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rem_content <span style="color:#f92672">=</span> rem_content[end_idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>].to_string();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And with that, we have our basic parser! It has several issues, so let&rsquo;s go over them one at a time. The most obvious one is that sometimes, LaTeX uses unnormalized Unicode to represent code points. There&rsquo;s also the issue of ligatures that some fonts support. We need to take care of these.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#e6db74">/// A lazy-loaded hashmap of octal character replacements post-parsing.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Some of these come across because of ligature support in fonts. This
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// is not exhaustive, however.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">OCTAL_REPLACEMENTS</span>: <span style="color:#a6e22e">Lazy</span><span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> Lazy::new(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> m <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">050&#34;</span>, <span style="color:#e6db74">&#34;(&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">051&#34;</span>, <span style="color:#e6db74">&#34;)&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">002&#34;</span>, <span style="color:#e6db74">&#34;fi&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">017&#34;</span>, <span style="color:#e6db74">&#34;*&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">227&#34;</span>, <span style="color:#e6db74">&#34;--&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">247&#34;</span>, <span style="color:#e6db74">&#34;Section &#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">223&#34;</span>, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">224&#34;</span>, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">000&#34;</span>, <span style="color:#e6db74">&#34;-&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Parse the weird octal representations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (from, to) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">OCTAL_REPLACEMENTS</span>.iter() {
</span></span><span style="display:flex;"><span>    parsed <span style="color:#f92672">=</span> parsed.replace(from, to);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="fin">Fin<a hidden class="anchor" aria-hidden="true" href="#fin">#</a></h1>
<p>There are a few more issues, but we will get to those in a future post. This is it for the first devlog. I will write more posts detailing how different components work as I write them.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Rahul&#39;s Blog</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
