<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>ZQA Devlog 02 | Rahul&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="This is part 2 of a series of posts logging development of a RAG system for Zotero that I&rsquo;m writing in Rust. Here is Part 1.
Towards parsing math
The next challenge to tackle is math: how does it work? Or more specifically: how are equations and inline mathematical symbols represented in the PDF content stream, and how can we use that information to parse them? For this, the best way to start is to simply create a very simple PDF with some commonly-used symbols and see what the content stream looks like. It&rsquo;s straightforward to generate this using LaTeX:">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/devlog/zqa-02/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/devlog/zqa-02/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
    
       <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    }
  };
</script>

    

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Rahul&#39;s Blog (Alt + H)">Rahul&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      ZQA Devlog 02
    </h1>
    <div class="post-meta"><span title='2025-07-07 21:44:00 -0400 EDT'>July 7, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>This is part 2 of a series of posts logging development of a RAG system for Zotero that I&rsquo;m writing in Rust. <a href="https://blog.ryedida.me/posts/devlog/zqa-01/">Here</a> is Part 1.</p>
<h1 id="towards-parsing-math">Towards parsing math<a hidden class="anchor" aria-hidden="true" href="#towards-parsing-math">#</a></h1>
<p>The next challenge to tackle is math: how does it work? Or more specifically: how are equations and inline mathematical symbols represented in the PDF content stream, and how can we use that information to parse them? For this, the best way to start is to simply create a very simple PDF with some commonly-used symbols and see what the content stream looks like. It&rsquo;s straightforward to generate this using LaTeX:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>begin
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">\sum</span> a <span style="color:#66d9ef">\sum\limits</span>_{i=0}^n b <span style="color:#66d9ef">\int</span> c <span style="color:#66d9ef">\int</span>_0^<span style="color:#66d9ef">\infty</span> d <span style="color:#66d9ef">\int\limits</span>_0^<span style="color:#66d9ef">\infty</span> e<span style="color:#66d9ef">\mathbb</span>{E}[x]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end
</span></span></code></pre></div><p>Note that we added two delimiter regular text phrases to help us know what parts of the PDF content stream to focus on. It does not matter that the equation makes no sense: we&rsquo;re interested in the content stream generated by this. For testing, it&rsquo;s easiest to simply put this in a test module and simply run that one test, changing the filename as necessary:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#75715e">#[cfg(test)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mod</span> tests {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Get the raw content stream for page `page_num` for the PDF.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_raw_content_stream</span>(doc: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Document</span>, page_num: <span style="color:#66d9ef">usize</span>) -&gt; Result<span style="color:#f92672">&lt;</span>String, PdfError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> page_id: (<span style="color:#66d9ef">u32</span>, <span style="color:#66d9ef">u16</span>) <span style="color:#f92672">=</span> doc
</span></span><span style="display:flex;"><span>            .page_iter()
</span></span><span style="display:flex;"><span>            .nth(page_num)
</span></span><span style="display:flex;"><span>            .ok_or(PdfError::ContentError)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> page_content <span style="color:#f92672">=</span> doc
</span></span><span style="display:flex;"><span>            .get_page_content(page_id)
</span></span><span style="display:flex;"><span>            .map_err(<span style="color:#f92672">|</span>_<span style="color:#f92672">|</span> PdfError::ContentError)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> String::from_utf8_lossy(<span style="color:#f92672">&amp;</span>page_content);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Ok(content.to_string())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_pdf_content</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> env::var(<span style="color:#e6db74">&#34;CI&#34;</span>).is_ok() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Skip this test in CI environments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> PathBuf::from(<span style="color:#e6db74">&#34;assets&#34;</span>).join(<span style="color:#e6db74">&#34;symbols.pdf&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> doc <span style="color:#f92672">=</span> Document::load(path).unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> get_raw_content_stream(<span style="color:#f92672">&amp;</span>doc, <span style="color:#ae81ff">0</span>).unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dbg!(content);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The relevant part of the content stream is here (I&rsquo;ve formatted and truncated it so it&rsquo;s clearer):</p>
<pre tabindex="0"><code>/F28 
9.9626 Tf 
0 -21.821 Td 
[(b)-28(egin)]TJ
/F21 
9.9626 Tf 
110.055 -23.039 Td 
[(X)]TJ
/F31 
9.9626 Tf 
16.051 -9.465 Td 
[(a)]TJ
/F30 
6.9738 Tf 
11.66 12.454 Td 
[(n)]TJ
/F21 
9.9626 Tf 
-4.733 -2.989 Td 
[(X)]TJ
/F30 
6.9738 Tf 
0.742 -21.219 Td 
[(i)]TJ
/F27 
6.9738 Tf 
2.819 0 Td 
[(=0)]TJ
...
...
-215.945 -29.623 Td 
[(end)]TJ 
154.421 -346.835 Td 
[(1)]TJ
ET
</code></pre><p>And if you&rsquo;re wondering, yes: PDFs <em>are</em> that chaotic. There&rsquo;s method to the madness, though. All the <code>/Fxx</code> commands you see are a change of font. PDF content streams contain a sequence of commands, with the parameters to the commands preceding them&ndash;and before you ask, I have absolutely no idea why. So <code>9.9626 Tf</code> tells the PDF renderer to set the text font to 9.9626pt (why not exactly 10? This has to do with font rendering and topics that quite frankly, I don&rsquo;t really understand yet). The <code>Td</code> commands tell the PDF renderer to move by a specific vertical and horizontal distance, and the <code>TJ</code> commands are text arrays, with specific spacing between grapheme clusters. The key here is that these are not <em>words</em>, just <em>grapheme clusters</em>. This means that kerning considerations during font rendering might mean words get split up (and quite often, they do&ndash;another annoying part of PDF parsing).</p>
<p>But this content stream gives us a hint as to how symbols might be rendered: the super- and subscripts can simply be handled using <code>Td</code> commands, but the symbols themselves are achieved through a change of <em>font</em>. For example, the first symbol we have is a summation symbol. We see that right after our &ldquo;begin&rdquo; delimiter, <code>pdflatex</code> changes the font to <code>F21</code>. In PDFs, fonts are&hellip;a complicated structure. Each page has a resources dictionary, that includes font definitions. The font definitions themselves are dictionaries that map font properties such as the name, its character map, etc. to potentially more dictionaries. In practice, these dictionaries are present elsewhere in the page resources dictionary and the values are simply resource identifiers, but if you put them all together, a good (if slightly inaccurate) mental model is of a triply-nested dictionary. <code>lopdf</code> makes parsing the dictionaries themselves pretty simple, so we just need to use the functions it provides:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span>    <span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_font_properties</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> env::var(<span style="color:#e6db74">&#34;CI&#34;</span>).is_ok() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Skip this test in CI environments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> font_key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;F21&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> PathBuf::from(<span style="color:#e6db74">&#34;assets&#34;</span>).join(<span style="color:#e6db74">&#34;symbols.pdf&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> doc <span style="color:#f92672">=</span> Document::load(path).unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> page_id <span style="color:#f92672">=</span> doc.page_iter().next().unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Get the font dictionary for the page
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> fonts <span style="color:#f92672">=</span> doc.get_page_fonts(page_id).unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> font_obj <span style="color:#f92672">=</span> fonts.get(font_key.as_bytes()).unwrap();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> font_hash <span style="color:#f92672">=</span> font_obj.as_hashmap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> readable_font_obj: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, <span style="color:#f92672">&amp;</span>Object<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> font_hash
</span></span><span style="display:flex;"><span>            .iter()
</span></span><span style="display:flex;"><span>            .map(<span style="color:#f92672">|</span>(k, v)<span style="color:#f92672">|</span> (String::from_utf8(k.clone()).unwrap(), v))
</span></span><span style="display:flex;"><span>            .collect();
</span></span><span style="display:flex;"><span>        dbg!(<span style="color:#f92672">&amp;</span>readable_font_obj);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>One other thing to note is that in PDFs, resources, including fonts, are represented by two numbers. Keep this in mind as we read the output of this function.</p>
<pre tabindex="0"><code>[pdftools/src/parse.rs:673:9] &amp;readable_font_obj = {
    &#34;ToUnicode&#34;: 20 0 R,
    &#34;BaseFont&#34;: /ETPJKV+CMEX10,
    &#34;Type&#34;: /Font,
    &#34;Widths&#34;: 47 0 R,
    &#34;LastChar&#34;: 90,
    &#34;Subtype&#34;: /Type1,
    &#34;FontDescriptor&#34;: 53 0 R,
    &#34;FirstChar&#34;: 88,
}
</code></pre><p>The first key is the <code>ToUnicode</code> character map, which is a pointer to a resource whose ID is the number pair 20, 0. We are not interested in that. We instead care about the font name itself, actually. The part before the + is just a string of random characters: it indicates that only the glyphs used in the document have been embedded into this PDF document, and not the entire font. We care about the rest of the name, <code>CMEX10</code>. This is LaTeX&rsquo;s <em>Computer Modern Math Extension</em> font. The 10 is the design size of the font. The next piece of the puzzle is to look at the rest of the content stream. The summation symbol has been represented by a single character, capital X. This is our hint to look at the actual font itself. On my system, this is located at <code>/usr/share/texmf-dist/fonts/afm/public/amsfonts/cm/cmex10.afm</code>. This path might as well be magic: I simply navigated to <code>/usr/share/texmf-dist/</code> (a directory I discovered exists by aggressively hitting tab on every <code>/usr/</code> subdirectory), and then simply running <code>fd cmex</code>. Then, I looked through the files one by one to see which made any sense. We know we&rsquo;re on the right track, because there&rsquo;s this line in this file:</p>
<pre tabindex="0"><code>C 88 ; WX 1444 ; N summationdisplay ; B 56 -1400 1387 0 ;
</code></pre><p>Capital X is ASCII 88, so it&rsquo;s promising that this lines up well. It turns out that this method of spelunking through the tex files to find the font mappings works quite well. Sadly, this doesn&rsquo;t use the exact LaTeX commands we used, but it&rsquo;s close enough that we can do some more manual labor, and from here, implementing the text substitutions themselves is trivial:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#75715e">// Just add a bunch of these.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from_cmex</span>(ch: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">u8</span>) -&gt; String {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> ch {
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">88</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">sum&#34;</span>.to_string(), <span style="color:#75715e">// X
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#ae81ff">90</span> <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">int&#34;</span>.to_string(), <span style="color:#75715e">// Z
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        _ <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">char</span>::from(<span style="color:#f92672">*</span>ch).to_string(),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A type to convert from bytes in math fonts to LaTeX code
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ByteTransformFn</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">fn</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">u8</span>) -&gt; String;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">font_transform</span>(input: String, transform: <span style="color:#a6e22e">ByteTransformFn</span>) -&gt; String {
</span></span><span style="display:flex;"><span>    input.as_bytes().iter().map(transform).collect::<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A lazy-loaded hashmap storing conversions from math fonts to LaTeX code
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Handles most common math fonts, but does not yet support specialized math fonts.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">FONT_TRANSFORMS</span>: <span style="color:#a6e22e">Lazy</span><span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;&amp;</span>&#39;static <span style="color:#66d9ef">str</span>, ByteTransformFn<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> Lazy::new(<span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> m: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;&amp;</span>&#39;static <span style="color:#66d9ef">str</span>, ByteTransformFn<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI5&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI6&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI7&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI8&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI9&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI10&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMMI12&#34;</span>, from_cmmi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMSY5&#34;</span>, from_cmsy);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMSY6&#34;</span>, from_cmsy);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMSY7&#34;</span>, from_cmsy);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMSY8&#34;</span>, from_cmsy);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMSY9&#34;</span>, from_cmsy);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMSY10&#34;</span>, from_cmsy);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;CMEX10&#34;</span>, from_cmex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;MSBM5&#34;</span>, from_msbm);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;MSBM6&#34;</span>, from_msbm);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;MSBM7&#34;</span>, from_msbm);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;MSBM8&#34;</span>, from_msbm);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;MSBM9&#34;</span>, from_msbm);
</span></span><span style="display:flex;"><span>    m.insert(<span style="color:#e6db74">&#34;MSBM10&#34;</span>, from_msbm);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>This is, admittedly, a bit of a hacky and harcoded solution, but it works, and is easy to re-reverse engineer. In our actual parser, this ends up being a matter of tracking <code>/F</code> commands to store state, and then using this hashmap as needed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(transform) <span style="color:#f92672">=</span> <span style="color:#66d9ef">FONT_TRANSFORMS</span>.get(self.cur_font.as_str()) {
</span></span><span style="display:flex;"><span>    parsed <span style="color:#f92672">+=</span> <span style="color:#f92672">&amp;</span>font_transform(cur_content[idx1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>idx2].to_string(), <span style="color:#f92672">*</span>transform);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    parsed <span style="color:#f92672">+=</span> <span style="color:#f92672">&amp;</span>cur_content[idx1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>idx2];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That&rsquo;s all that&rsquo;s needed! We can now test that this works, this time with a <em>real</em> test:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rs" data-lang="rs"><span style="display:flex;"><span><span style="color:#75715e">#[test]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_math_parsing_works</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> PathBuf::from(<span style="color:#e6db74">&#34;assets&#34;</span>).join(<span style="color:#e6db74">&#34;symbols.pdf&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> extract_text(path.to_str().unwrap());
</span></span><span style="display:flex;"><span>    assert!(content.is_ok());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> content.unwrap();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> op <span style="color:#66d9ef">in</span> [<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;\int&#34;</span>, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;\sum&#34;</span>, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;\infty&#34;</span>] {
</span></span><span style="display:flex;"><span>        assert!(content.contains(op));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="fin">Fin<a hidden class="anchor" aria-hidden="true" href="#fin">#</a></h1>
<p>This whole adventure of figuring out how equations are rendered, finding the font file locations, and even figuring out what <code>CMEX</code> meant took me a few months, but it&rsquo;s quite nice to see it finally work the way I want&ndash;rewriting the content stream into a LaTeX representation, which is what we want stored in our vector database. With this, our PDF parser is in a slightly nicer state, but there&rsquo;s still the issue of tables, images, and more complicated math equations.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Rahul&#39;s Blog</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
