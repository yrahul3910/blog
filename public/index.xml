<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rahul&#39;s Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Rahul&#39;s Blog</description>
    <generator>Hugo -- 0.140.1</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 19 Oct 2025 12:00:00 -0400</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>On LLM-based TUI coding assistants</title>
      <link>http://localhost:1313/posts/tech/cli-agents/</link>
      <pubDate>Sun, 19 Oct 2025 12:00:00 -0400</pubDate>
      <guid>http://localhost:1313/posts/tech/cli-agents/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Over the past few months, it seems that Big AI™ has finally listened to us terminal users. As someone who exclusively uses nvim + tmux, I did (and continue to) not care about most of the AI-in-IDE assistants, since most of them seemed catered to VS Code (and its forks) or JetBrains users. Neovim has plugins that offer similar functionality such as Avante, and while they work great (so I&amp;rsquo;ve heard), they&amp;rsquo;re all entirely community-driven (but it is worth mentioning that Microsoft did release a vim plugin for Copilot, which a community member kindly ported to neovim and continues to maintain to this day).&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZQA Devlog 02</title>
      <link>http://localhost:1313/posts/devlog/zqa-02/</link>
      <pubDate>Mon, 07 Jul 2025 21:44:00 -0400</pubDate>
      <guid>http://localhost:1313/posts/devlog/zqa-02/</guid>
      <description>&lt;p&gt;This is part 2 of a series of posts logging development of a RAG system for Zotero that I&amp;rsquo;m writing in Rust. &lt;a href=&#34;https://blog.ryedida.me/posts/devlog/zqa-01/&#34;&gt;Here&lt;/a&gt; is Part 1.&lt;/p&gt;
&lt;h1 id=&#34;towards-parsing-math&#34;&gt;Towards parsing math&lt;/h1&gt;
&lt;p&gt;The next challenge to tackle is math: how does it work? Or more specifically: how are equations and inline mathematical symbols represented in the PDF content stream, and how can we use that information to parse them? For this, the best way to start is to simply create a very simple PDF with some commonly-used symbols and see what the content stream looks like. It&amp;rsquo;s straightforward to generate this using LaTeX:&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZQA Devlog 01</title>
      <link>http://localhost:1313/posts/devlog/zqa-01/</link>
      <pubDate>Wed, 16 Apr 2025 20:23:29 -0400</pubDate>
      <guid>http://localhost:1313/posts/devlog/zqa-01/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This is the first in a series of posts logging the development of &lt;code&gt;zqa&lt;/code&gt;, a RAG tool I am working on to work with Zotero. The eventual goal is that you will be able to, from your terminal (as an avid terminal user myself), ask questions and have LLMs respond with citations from your Zotero library. I also want this tool to help you find things: so maybe you remember certain details about a paper but don&amp;rsquo;t quite know what it was about or its title&amp;ndash;a problem that has become all too real with my 1,300-item library. Why is it called &lt;code&gt;zqa&lt;/code&gt;? Because I&amp;rsquo;m not creative, and &amp;ldquo;Zotero Q &amp;amp; A&amp;rdquo; was the first thing that popped into my head. Also, the letters in &lt;code&gt;zqa&lt;/code&gt; happen to be very close, so it&amp;rsquo;s easy enough to type.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Using Google Cloud to host multiple servers on one VM</title>
      <link>http://localhost:1313/posts/gcloud/multiple-servers-vm/</link>
      <pubDate>Sat, 14 Jan 2023 00:00:00 -0400</pubDate>
      <guid>http://localhost:1313/posts/gcloud/multiple-servers-vm/</guid>
      <description>&lt;p&gt;This blog post presents a solution to the following problem: we want to host two services, and have &lt;code&gt;test1.example.com&lt;/code&gt; and &lt;code&gt;test2.example.com&lt;/code&gt; route to them respectively. These services should run on one machine, on different ports. Google Cloud Load Balancing makes this relatively easy, although nginx solutions exist.&lt;/p&gt;
&lt;h2 id=&#34;step-1-set-up-a-vm&#34;&gt;Step 1: Set up a VM&lt;/h2&gt;
&lt;p&gt;We’ll create a VM with default settings. Create two directories, test1 and test2 inside the VM. Within both, we’ll create the same file called &lt;code&gt;server.js&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
